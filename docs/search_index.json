[["index.html", "Методы анализа больших данных в исследованиях поведения покупателей Intro", " Методы анализа больших данных в исследованиях поведения покупателей Ph.A.Upravitelev 2023-09-27 Intro "],["c1_intro.html", "О курсе и аналитиках Запись занятия Обо мне Contacts О курсе Виды аналитиков Продуктовая аналитика Стадии развития продукта Бизнес-модели Полезные материалы Домашнее задание", " О курсе и аналитиках Запись занятия Обо мне продуктовый аналитик в Pixonic продуктовый аналитик в GameInsight аналитик в Консультант+ аспирант СПбГУ (когнитивная психология) Contacts @konhis в mar221.slack.com (основное средство коммуникации) upravitelev@gmail.com (дополнительное средство коммуникации) +7-965-425-5919 или @konhis в telegram (для экстренных случаев) О курсе темы лекций Введение в цели и задачи продуктовой аналитики Метрики активности и вовлечения пользователей Основы юнит-экономики и метрики монетизации пользователей Проверка гипотез А/B-тесты Создание и тестирование фич (feature) факультативно если будет достаточно желающих, можно одно-два занятия посвятить основам SQL. Ни в домашках, ни в контрольных знание SQL не потребуется, это именно дополнительные темы. я хочу пригласить несколько аналитиков-практиков, чтобы они рассказали о каких-то частных темах из жизни аналитиков. формы контроля две контрольные работы две домашние работы накопительная оценка по формуле 0.1 * Кр1 + 0.35 * Др1 + 0.2 * Кр2 + 0.35 * Др2, округление арифметическое. Виды аналитиков data scientists Датасаентисты - общее определение нескольких профессий. Основной набор навыков – математика, программирование и знание бизнес-задач. Сочетание этих навыков в разных пропорциях и характеризует разные виды датасаентистов. Аналитики должны хорошо понимать бизнес-задачи проекта и специфику бизнеса, к тому же сейчас профессия аналитика предполагает хорошее знание статистики и хотя бы начальные навыки программирования. web-аналитика Задачи: сбор и анализ данных о посетителях веб-сайтов и их поведении на сайте Инструменты: Google Analytics, Яндекс.Метрика, Google Tag Manager маркетинговая аналитика Задачи: оценка эффективности маркетинга (UA, привлечение пользователей) Инструменты: Amplitude, Appsflyer, Facebook etc Есть маркетинговая аналитика, которая касается исследований рынка и так далее. Там совершенно иные требования к навыкам и задачи. Продуктовая аналитика что такое продукт Все, что может быть предложено на рынке с целью удовлетворения чьих-либо желаний и потребностей. В IT под продуктом обычно понимают приложение или какой-то функционал приложения. Соответственно, продуктовая аналитика — анализ того, как пользователи взаимодействуют с приложением и предложенным функционалом (и как за него платят). Близко к web-аналитике, но отличается более детальными данными про пользователя и его поведение, а не просто статистику страниц и переходов. CX/UX-исследователи Тоже близки к продуктовым аналитикам, но больше ориентированы на опыт пользователя и то, как он взаимодействует с приложением (интерфейс) и как использует приложение для решения своих задач. Основные методы – интервью, опросы, фокус-группы, UX-тесты и т.д. структура команды разработки Продуктовые аналитики тесно взаимодействуют с командами разработки (особенно если это мобильные приложения), в основном с продюсерами и разработчиками (особенно на этапе построения систем аналитики новых продуктов), с отделом маркетинга, существенно реже - с коммьюнити-менеджерами. продакт-менеджер / продюсер проджект-менеджер (PM) разработчики (клиент/сервер) дизайнеры (арт), UI аналитики тестировщики системные администраторы коммьюнити саппорт роли продуктовых аналитиков калькулятор интерфейс к базе данных специалист по дашбордам аналитик фич и апдейтов генератор идей / мастер на все руки Стадии развития продукта этапы жизни технические этапы Концепт Прототип Продукт, готовый к запуску Soft launch Global launch Оперирование Поддержка Чаще всего, конечно, продуктовые аналитики работают с продуктом в стадии оперирования - когда идет эволюционное развитие, постоянный приток новых пользователей и есть активная команда разработки. Основные задачи: анализ фич (функционала), контроль баланса, улучшение UX, поддержка продактов при проектировании новых фич. Также аналитики работают с продуктом, готовым к первому запуску и на этапах soft/global launch. Это периоды построения системы аналитики и тестирование, как пользователи реагируют в целом на продукт и на ключевой функционал продукта. Бизнес-модели компоненты все, что связано с разработкой и производством продукта все, что связано с продажей продукта, от поиска нужных клиентов до распространения продукта все, что связано с тем, как клиент будет платить и как компания будет зарабатывать варианты Производство Дистрибьюция Freemium Подписные модели Агрегаторы и уберизация as a Service … тысячи их Полезные материалы рассказ Алексея Натекина про виды датасаентистов рассказ Валерия Бабушкина про то, почему датасаентист - очень общий термин Неплохая статья одного из аналитиков Яндекса. Его мысль про партизанской продакт-менеджмент наглядно описывает, какая роль аналитика в команде самая эффективная и, в общем-то, интересная. Хороший доклад про роли аналитиков в продуктовых (в первую очередь геймдев) командах. Немного многословно, но основные пункты освещены. пара слов про бизнес-модели (я частично ориентировался на эти материалы): раз, два и три телеграм-канал про стартапы, любопытно посмотреть, какие вообще бывают идеи стартапов и на удовлетворение каких потребностей они ориентированы Домашнее задание Промежуточные задания необязательны и нужны для тех, кто хочет развивать свои навыки в области аналитики или в R/Python/SQL. Те, кто решит выполнять задания и кому нужны будут комментарии — присылайте решения в личку в slack. О занятиях, которые будут оцениваться, я сообщу отдельно и не один раз. Для тех, кто не был на прошлом курсе Проверьте и при необходимости отредактируйте профиль в Slack: необходимо указать имя и фамилию (латиницей, в виде Name Family name), по возможности поставьте свою фотографию на аватарку. Всем: В канале #welcome напишите несколько слов о себе: какой опыт работы с R и вообще языками программирования, есть ли опыт работы аналитиком (и где, если есть). Какие ожидания от курса, какие темы вам интереснее всего. подумайте и напишите, каких специалистов и из каких компаний вы хотели бы послушать (кого стоит попробовать пригласить). Не какие-то конкретные люди, а роли. посмотрите на ваши установленные приложения и подумайте, какие ваши потребности они реализуют попробуйте определить, как организован поток денег от вас к компании в ваших приложениях, за что вы платите и как попробуйте определить самое интересное для себя приложение с точки зрения потребностей и их монетизации Если есть желание развиваться в сфере аналитики и продуктовой аналитики: напишите мне о своем желании в личку в slack и скажите, какие навыки лично вы хотели бы подтянуть во время курса. поищите различные вакансии веб-аналитиков, продуктовых и маркетинговых аналитиков. Посмотрите требуемые основные навыки: что из этого вы уже умеете, чему хотели бы научиться, а чем даже понятия не имеете. Определите зону или траекторию своего развития. Если считаете, что я могу помочь вам с этим – напишите, попробуем. "],["метрики-вовлечения-pt1.html", "Метрики вовлечения pt1 Запись занятия AARRR фреймворк User Aquisition Активность и вовлечение Полезные материалы Домашнее задание", " Метрики вовлечения pt1 Запись занятия AARRR фреймворк User Aquisition Метрики привлечения пользователей в основном используются маркетинговыми аналитиками и специалистами по user aquisition, привлечению пользователей. Продуктовые аналитики в основном работают с метриками стоимости пользователя: CPA (cost per action), CPI (cost per install), хотя иметь представления о прочих метриках тоже надо. Процесс привлечения пользователей рекламодатель (тот, кто хочет привлечь пользователей) аукцион рекламной площадки (рекламная площадка выбирает, кому, когда и по какой цене показыть рекламные материалы) целевые действия (установка, платеж и т.д.) (в зависимости от того, на выполнение какого целевого действия оптимизируется рекламная сеть, в приложение будут приходить разные пользователи - те, кто вероятнее всего установит приложение/сделает платеж / сделает другое целевое действие) управление кампанией - таргетинг, бюджет, креативы (рычагов управления рекламными кампаниями не так уж и много - на кого ориентируем рекламу, какой бюджет в день рекламная сетка может потратить на привлечение пользователей, какие рекламные атериалы показываем) Маркетинговая воронка в мобильных приложениях Когда пользователи видят рекламу, они проваливаются в “воронку” — последовательность шагов, которые приводят пользователя в приложение. Вообще воронки — полезный инструмент для оценки, где и на каком этапе отваливается пользователь. реклама (баннер, playable, прочий креатив): CPM (cost per mille - сколько платим за каждые 1000 показов рекламных материалов), CPC (cost per click - сколько платим рекламной сетке за каждый клик по баннеру), СTR(click through rate – клики / показы) переход в стор установка приложения (CR, conversion rate, регистрации / показы) целевое действие (CPI, CPA) Новый пользователь Основная цель рекламных кампаний – привлечение пользователей в приложение. Одна из базовых метрик этого процесса – количество новых пользователей. Однако есть сложности с самим определением, что такое новый пользователь. В частности, считать инсталлом новое физическое устройство. Или новый аккаунт пользователя. Или пользователя, который сделал покупку / подписку (e-comm, в частности). Например, когда пользователь на новый телефон устанавливает приложение и туда происходит логин с помощью его гугл/эппл аккаунта. В этом смысле устройство новое (а маркетинг закупает девайсы), а пользователь старый. Или когда пользователь пользовался приложением на телефоне. Потом удалил и через пару лет увидел рекламу и поставил заново и создал новый аккаунт. Или просто отдал телефон кому-то. Девайс старый, а пользователь новый. Другая история с новыми пользователями – это механизмы ретаргетинга. Это когда мы стараемся вернуть в приложение пользователей, которые уже были нашими пользователями, но потом отвалились. Например, мы выбираем набор девайсов с каким-то суммарным платежом более X единиц, и просим рекламной сетке именно этим устройствам показать нашу рекламу, с помощью которой мы надеемся вернуть пользователей. Этих пользователей сложно считать новыми, но рекламная кампания на них была и, соответственно, сколько-то мы потратили на возвращение этих пользователей. Активность и вовлечение Другая группа метрик - метрики активности и вовлечения пользователей в продукт. К этим метрикам относят обычно количество заходов пользователя в день (количество сессий), количество уникальных пользователей, заходящих в день в приложение. В некоторых случаях считают более длинные метрики - количество уникальных пользователей, зашедших в приложение в последнюю неделю/месяц. DAU, WAU, MAU Daily Active Users Weekly Active Users Monthly Active Users Основная метрика - DAU, как наиболее гибкая и быстро реагирующая на изменения в продукте. Месячные и недельные метрики считаются в скользящем окне, за последние 30 и 7 дней для каждой даты соответственно. Stickness / Sticky factor Иногда смотрят отношение DAU/MAU и интерпретируют как метрику залипания пользователя в проект, его лояльности. В целом это метрика вполне хорошо заменяется метриками удержания (retention). Retention rate Метрика удержания пользователя (retention) — какая доля пользователей вернулась в приложение. Во многом формула расчета ретеншена зависит от того, что мы считаем точкой отсчета. Когда речь идет о мобильных приложениях развлекательного плана (игры, стриминговые сервисы и проч.), то точкой отсчета обычно считают день инсталла, когда пользователь установил приложения. В некоторых продуктах может быть иначе, например, в e-commerce или в сервисах, предлагающих определенные услуги оффлайн (доставка продуктов), считаются только возвраты тех пользователей, которые сделали уже платеж. В целом, метрика удержания одна из важнейших в аналитике - она позволяет понимать, насколько пользователям интересно приложение (сервис), останутся ли они в нем. Соответственно, это прямо влияет на монетизацию: когда пользователи остаются, они либо больше платят, либо, как минимум, есть шансы их побудить сделать платеж (скидками, новыми фичами и т.д.) Нюансы: install day = day 0: традиционно день инсталла считается нулевым днем. day 1/7/14/28: полезно иметь в виду, что бывают циклы, например, ретеншен в течение недели может варьировать в определенном диапазоне. Соответственно, сравнивать два периода/объекта/тестовых группы хорошо бы по одному и тому же по структуре интервалу. проблема интервала (сутки vs календарная дата): обычно считается ретеншен по календарным дням, то есть, если произошла смена даты, то это уже другой день, даже если пользователь установил приложение в 23.55. Временами встречаются вычисления ретеншена строго по 24 часовым интервалам (вернувшийся в игру через 24 часа). Метрики удержания по этим двум формулам вычисления различаются, всегда надо уточнять, как именно велся расчет. rolling retention: иногда нет возможности логировать каждый заход пользователя в приложение, поэтому используется только дата последнего захода пользователя в приложение - то есть, считается, какая доля пользователей заходила после N дня от инсталла. Иногда retention 1 дня / удержание 1 дня сокращают до ret1 / ret1d, r1 (номер дня может быть любым, не только 1). однородность когорт: когда мы считаем удержание по когорте пользователей (например, пришедшим в сентябре), то мы должны считать ретеншен только того дня, который могли прожить все пользователи. То есть, на момент 3 сентября нельзя считать ретеншен 7 дня для тех, кто пришел в приложение 31 августа - они принципиально не могли прожить 7 дней, максимум - 2 (день инсталла и 1-2 октября, 3 сентября также нельзя считать, так как день еще не закончился). Соответственно, по всей месячной когорте можно считать только ret2, даже для тех, кто пришел в начале сентября и мог провести в приложении больше дней. Иногда это минимальное количество дней, которые могли прожить пользователи всех когорт, называют окном лайфтайма. Churn rate Отвалы (churn, отток) - ситуация, когда пользователь окончательно уходит из приложения. Как правило, это достаточно определить, что пользователь больше не вернется, поэтому операционализируют в духе “отвалившийся пользователь - пользователь, который был неактивен последние N дней”. Также как и ретеншен, операционализация отвала может зависеть от приложения и сервиса. Стоить помнить, что отток не тождественен удержанию с другим знаком, хотя достаточно близок по смыслу. Sessions per day Еще одна метрика вовлеченности пользователя в продукт - сколько раз пользователь открывает приложение в течение дня. В более общем виде - какие-то значимые активные действия в единицу времени. Количество сессий в день можно интерпретировать как степень рутинизированности, включенности в повседневные практики пользователя. Для разных продуктов и сервисов, само собой, будут свои критерии - для игр жанра match3 нормально, если пользователь 4-6 раз в день открывает приложение. А вот для приложения оплаты штрафов или банковских приложений это была бы странная метрика, там вообще могут потребоваться другие способы измерения и вовлечения. Полезные материалы Статья про Rolling retention и Retention rate от Олега Якубенкова. Статья от dev2dev про Retention. Список фреймфорков, которые используют продуктовые менеджеры в своей работе. Оффтоп: cмешной случай, как потеряли информацию о 16 тысячах заболевших граждан. Хороший пример, почему для работы с большими данными (да и просто с данными) Excel не очень полезен. Домашнее задание Домашние занятия для желающих. Если будут вопросы или необходимость получить от меня какие-то комментарии - пишите в личку в slack. Задание можете выполнять на любом доступном вам языке / среде для статистики. level 1 (IATYTD) Прочитайте конспект. Обновите знания по работе с табличками — аггрегации (групировки), слияния, создание и модификация колонок. Ссылка на конспекты прошлого курса: https://hse_mar.gitlab.io/mar221s/ (если у вас ссылка не открывается без VPN, скажите мне об этом, пожалуйста) level 2 (HNTR) Необходимо подсчитать и нарисовать, сколько пользователей в день приходит в приложение, в том числе и с разбивкой по платформам. Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv level 3 (HMP) Используя датасет по заходам пользователей в приложение (dau.csv), подсчитайте и отобразите на графике, сколько пользователей в день заходит в приложение (DAU). Ссылка на файл. Осторожно, файл около 400мб. level 4 (UV) На основе данных по логинам нарисуйте area plot DAU проекта, в котором цветами выделите группы пользователей по количеству дней с момента инсталла: группа 1: 0 дней с инсталла группа 2: 1-7 дней с момента инсталла группа 3: 8-28 дней с инсталла группа 4: более 28 дней с инсталла У вас должно получится что-то вроде слоеного пирога, где цветами выделены группы. Подумайте, есть ли необходимость рисовать этот график не в абсолютных числах (количество пользователей), а в долях каждой группы от DAU, в чем могут быть плюсы и минусы такого графика. Возможно, вам потребуется нарисовать графики разных типов, чтобы ответить на этот вопрос. Попробуйте подумать, что говорит подобный график о продукте и его пользователях. Есть ли у него проблемные зоны, над которыми надо поработать или которые могут влиять на стратегию развития и/или оперирования продукта? level 5 (N) Постройте графики DAU, MAU и их отношения для данных за июль. Проинтерпретируйте метрику DAU/MAU, что она говорит о проекте? "],["метрики-вовлечения-pt2.html", "Метрики вовлечения pt2 Запись занятия Расчет retention Домашнее задание", " Метрики вовлечения pt2 Запись занятия level 2 (HNTR) Необходимо подсчитать и нарисовать, сколько пользователей в день приходит в приложение, в том числе и с разбивкой по платформам. Датасет: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv Решение: # подключаем пакеты (они до этого должны быть установлены) library(data.table) library(plotly) # если есть ошибка с %&gt;%, то явно подключаем соответствующий пакет library(magrittr) # импортируем данные installs &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv&#39;) # считаем количество уникальных пользователей по дням intalls_stat &lt;- installs[, list(n_users = uniqueN(user_pseudo_id)), by = list(dt, media_source)] # сортируем по дате инсталла intalls_stat &lt;- intalls_stat[order(dt)] # рисуем график plot_ly(intalls_stat, x = ~dt, y = ~n_users, color = ~media_source, type = &#39;scatter&#39;, mode = &#39;none&#39;, stackgroup = &#39;one&#39;) %&gt;% layout( title = &#39;Установки приложения по дням&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(title = &#39;&#39;, rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) level 4 (UV) На основе данных по логинам нарисуйте area plot DAU проекта, в котором цветами выделите группы пользователей по количеству дней с момента инсталла: группа 1: 0 дней с инсталла группа 2: 1-7 дней с момента инсталла группа 3: 8-28 дней с инсталла группа 4: более 28 дней с инсталла У вас должно получится что-то вроде слоеного пирога, где цветами выделены группы. Подумайте, есть ли необходимость рисовать этот график не в абсолютных числах (количество пользователей), а в долях каждой группы от DAU, в чем могут быть плюсы и минусы такого графика. Возможно, вам потребуется нарисовать графики разных типов, чтобы ответить на этот вопрос. Попробуйте подумать, что говорит подобный график о продукте и его пользователях. Есть ли у него проблемные зоны, над которыми надо поработать или которые могут влиять на стратегию развития и/или оперирования продукта? Решение: # импортируем даатсает dau &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/dau.csv&#39;) # считаем количество дней от инсталла dau[, lifetime := login_dt - install_dt] # делим на группы dau[, lifetime_group := cut(lifetime, breaks = c(-Inf, -1, 0, 7, 28, Inf), ordered_result = TRUE)] # если хотим перезадать порядок уровней # dau[, lifetime_group_ := factor(lifetime_group, # levels = c(&#39;(-1,0]&#39;, # &#39;(28, Inf]&#39;, &#39;(0,7]&#39;, # &#39;(7,28]&#39;, &#39;(-Inf,-1]&#39;))] # второй стобоб разметить группы # dau[lifetime == 0, lifetime_group_3 := &#39;0. 0 day&#39;] # dau[lifetime &gt;= 1 &amp; lifetime &lt;= 7, lifetime_group_3 := &#39;1. 1-7 days&#39;] # dau[lifetime &gt;= 8 &amp; lifetime &lt;= 28, lifetime_group_3 := &#39;2. 8-28 days&#39;] # dau[lifetime &gt;= 28 &amp; lifetime &lt;= 90, lifetime_group_3 := &#39;3. 28+ days&#39;] # создаем отдельную группу для тех, про кого мы не знаем # dau[is.na(lifetime_group), lifetime_group_3 := &#39;unknown&#39;] # третий метод, с помощью fcase # dau[, lifetime_group := fcase( # lifetime == 0, &#39;0 дней&#39;, # lifetime &gt;= 1 &amp; lifetime &lt;= 7, &#39;1-7 дней&#39; # )] # считаем DAU dau_stat &lt;- dau[, list(n_users = uniqueN(user_pseudo_id)), keyby = list(login_dt, lifetime_group)] dau_stat[, total_users := sum(n_users), by = login_dt] dau_stat[, share := n_users / total_users] # area-plot plot_ly(dau_stat, x = ~login_dt, y = ~n_users, color = ~lifetime_group, type = &#39;scatter&#39;, mode = &#39;none&#39;, stackgroup = &#39;one&#39;) %&gt;% layout( title = &#39;DAU по группам пользователей&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(title = &#39;&#39;, rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) # график линиями plot_ly(dau_stat, x = ~login_dt, y = ~n_users, color = ~lifetime_group, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;DAU по группам пользователей&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(title = &#39;&#39;, rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) level 5 (N) Постройте графики DAU, MAU и их отношения для данных за июль. Проинтерпретируйте метрику DAU/MAU, что она говорит о проекте? Решение. Строим график MAU. # берем интересующие нас дни dates &lt;- dau[login_dt &gt;= &#39;2022-07-01&#39;, sort(unique(login_dt))] # проходим циклом lapply mau_stat &lt;- lapply(dates[1:2], function(x) { # берем данные в интервале &quot;наша дата - 30 дней -- наша дата&quot; result &lt;- dau[login_dt &gt;= x - 30 &amp; login_dt &lt;= x] # считаем, сколько пользователей заходило за это время (mau) result &lt;- result[, list(dt = x, dt_lb = x - 30, mau = uniqueN(user_pseudo_id))] result }) # собираем все в табличку mau_stat &lt;- rbindlist(mau_stat) # аналогичное решение, более современное по функциям # + считаем одновременно dau и mau library(purrr) mau_stat &lt;- map_df(dates, function(x) { result &lt;- dau[, list( dt = x, dt_lb = x - 30, metric_dau = uniqueN(user_pseudo_id[login_dt == x]), metric_mau = uniqueN(user_pseudo_id[login_dt &gt;= x - 30 &amp; login_dt &lt;= x]) )] result }) setDT(mau_stat) # считаем stickiness mau_stat[, stickiness := metric_dau / metric_mau] # рисуем DAU и MAU plot_ly(mau_stat, x = ~dt, y = ~metric_mau, type = &#39;scatter&#39;, mode = &#39;lines&#39;, name = &#39;MAU&#39;) %&gt;% add_trace(y = ~metric_dau, name = &#39;DAU&#39;) %&gt;% layout( title = &#39;DAU и MAU&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) %&gt;% config(displayModeBar = FALSE) # рисуем stickiness plot_ly(mau_stat, x = ~dt, y = ~stickiness, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;DAU / MAU&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) %&gt;% config(displayModeBar = FALSE) Расчет retention Общая логика расчета: - считаем lifetime - считаем количество пользователей на каждый день от инсталла - считаем долю этих пользователей от всего пользователей когорты - ограничиваем на общий доступный лайфтайм - рисуем график - опционально – добавляем группировку # берем только тех, кто пришел в июне retention &lt;- dau[install_dt &gt;= &#39;2022-06-01&#39;] retention &lt;- retention[install_dt &lt; &#39;2022-07-01&#39;] # ограничиваем на минимальное общее количество дней retention &lt;- retention[lifetime &lt;= 30 &amp; lifetime &gt;= 0] # считаем количество вернувшихся retention_stat &lt;- retention[, list(returned = uniqueN(user_pseudo_id)), keyby = list(platform, lifetime)] # считаем,с колько всего было retention_stat[, total_users := returned[lifetime == 0], by = platform] # второй вариант расчета total_users, через merge retention_stat &lt;- merge( retention_stat, retention_stat[lifetime == 0, list(platform, total_users_2 = returned)], by = &#39;platform&#39;, all.x = TRUE ) # считаем retention retention_stat[, ret := returned / total_users] # рисуем график plot_ly(retention_stat, x = ~lifetime, y = ~ret, color = ~platform, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;Retention rate&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) %&gt;% config(displayModeBar = FALSE) Домашнее задание level 1 (IATYTD) Внимательно разберите решения заданий (материалы конспекта). level 2 (HNTR) Постройте график ретеншена для когорты пользователей, пришедшей в июне, с разбивкой по источникам привлечения (media_source). Для этого вам потребуются следующие датасеты: Инсталлы: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv Логины: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/dau.csv level 3 (HMP) Постройте линейный график retention 1 day (ret1) для всех дневных когорт. Т.е. по оси OX должна быть дата инсталла, по оси OY – значение ретеншена первого для пользователей, пришедших в этот день. level 4 (UV) Добавьте на этот график группировку по источникам трафика (media_source). level 5 (N) Постройте и сравните графики rolling retention и retention rate (возьмите данные за логины и инсталлы из практикума). Для rolling retention необходимо: посчитать максимальный лайфтайм пользователя gосчитать количество пользователей по лайфтайму cделать обратную кумулятивную сумму cумму поделить на количество установок (для lifetime == 0 значения количества инсталлов и обратная кумсумма должны совпадать) "],["c4_monetization.html", "Метрики монетизации pt.1 Запись занятия Разбор домашнего задания Платежные метрики Полезные материалы Домашнее задание", " Метрики монетизации pt.1 Запись занятия Разбор домашнего задания level 2 (HNTR) Постройте график ретеншена для когорты пользователей, пришедшей в июне, с разбивкой по источникам привлечения (media_source). Для этого вам потребуются следующие датасеты: Инсталлы: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv Логины: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/dau.csv library(data.table) library(plotly) installs &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv&#39;) dau &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/dau.csv&#39;) # присоединяем источники трафика retention &lt;- merge( installs[dt &lt; &#39;2022-07-01&#39;, list(user_pseudo_id, dt, media_source)], dau[, list(user_pseudo_id, login_dt)], by = &#39;user_pseudo_id&#39;, all.x = TRUE ) # перекодируем retention[, uniqueN(user_pseudo_id), by = media_source] ## media_source V1 ## 1: applovin_int 36714 ## 2: &lt;NA&gt; 36169 ## 3: other 6869 ## 4: unityads_int 21932 ## 5: googleadwords_int 7767 ## 6: Facebook Ads 1297 ## 7: organic 32 retention[is.na(media_source), media_source := &#39;organic&#39;] retention[media_source == &#39;other&#39;, media_source := &#39;organic&#39;] # вычисляем лайфтайм retention[, lifetime := login_dt - dt] # убираем реинсталлы и ограничиваем на минимальное общее окно retention &lt;- retention[!user_pseudo_id %in% retention[lifetime &lt; 0, unique(user_pseudo_id)]] retention &lt;- retention[lifetime &lt;= 30] # читаем количество вернувшихся пользователей retention_stat &lt;- retention[, list(returned = uniqueN(user_pseudo_id)), keyby = list(media_source, lifetime)] # считаем всего пользователей retention_stat[, total_users := returned[lifetime == 0], by = media_source] # альтернативный вариант # retention_stat &lt;- merge( # retention_stat, # retention_stat[lifetime == 0, list(media_source, total_users_2 = returned)], # by = &#39;media_source&#39;, all.x = TRUE # ) # считаем ретеншен retention_stat[, ret := returned / total_users] plot_ly(retention_stat, x = ~lifetime, y = ~ret, color = ~media_source, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;Ретеншен по источникам пользователей&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) %&gt;% config(displayModeBar = FALSE) level 3 (HMP) Постройте линейный график retention 1 day (ret1) для всех дневных когорт. Т.е. по оси OX должна быть дата инсталла, по оси OY – значение ретеншена первого для пользователей, пришедших в этот день. level 4 (UV) Добавьте на этот график группировку по источникам трафика (media_source). # пересобираем датасет retention_daily &lt;- merge( installs[, list(user_pseudo_id, dt, media_source)], dau[, list(user_pseudo_id, login_dt)], by = &#39;user_pseudo_id&#39;, all.x = TRUE ) retention_daily[is.na(media_source), media_source := &#39;organic&#39;] retention_daily[media_source == &#39;other&#39;, media_source := &#39;organic&#39;] retention_daily[, uniqueN(user_pseudo_id), by = media_source] ## media_source V1 ## 1: applovin_int 36818 ## 2: organic 57690 ## 3: unityads_int 22017 ## 4: googleadwords_int 7774 ## 5: Facebook Ads 1297 retention_daily[, lifetime := login_dt - dt] retention_daily &lt;- retention_daily[!user_pseudo_id %in% retention_daily[lifetime &lt; 0, unique(user_pseudo_id)]] # считаем по дням инсталла вернувшихся на lifetime == 0 retention_daily_stat &lt;- merge( retention_daily[lifetime == 0, list(total_users = uniqueN(user_pseudo_id)), by = list(dt, media_source)], retention_daily[lifetime == 1, list(returned_d1 = uniqueN(user_pseudo_id)), by = list(dt, media_source)], by = c(&#39;dt&#39;, &#39;media_source&#39;), all.x = TRUE ) # считаем ретеншен retention_daily_stat[, ret1 := returned_d1 / total_users] retention_daily_stat &lt;- retention_daily_stat[order(dt)] setkey(retention_daily_stat, dt) plot_ly(retention_daily_stat, x = ~dt, y = ~ret1, color = ~media_source, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;Динамика retention 1 day по дням&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) %&gt;% config(displayModeBar = FALSE) level 5 (N) Постройте и сравните графики rolling retention и retention rate (возьмите данные за логины и инсталлы из практикума). # считаем rolling retention # сначала вычисляем максимальную дату захода по каждому пользователю rret &lt;- retention[, list(lifetime = max(lifetime)), by = user_pseudo_id] # считаем количество дней от инсталла до последнего логина rret_stat &lt;- rret[, list(rret_users = uniqueN(user_pseudo_id)), by = lifetime] # нужна обратная кумулята, так как мы считаем &quot;сколько вернулось после дня x&quot; # а в статистике у нас &quot;для какого количества пользователей это был последний день&quot; - то есть, для каждого дня надо получить, # накопительную сумму этого и всех следующих дней. а это делается с помощью обратной кумуляты # для этого мы переворачиваем значения колонки с помощью rev(), считаем обычную кумуляту # а потом результат переворачиваем обратно # чтобы понять результат, попробуйте выражения: 1:5; rev(1:5), cumsum(1:5), cumsum(rev(1:5)), rev(cumsum(rev(1:5))) setkey(rret_stat, lifetime) rret_stat[, rret_users_cum := cumsum(rret_users)] rret_stat[, rret_users_cum_rev := cumsum(rev(rret_users))] rret_stat[, rret_users_cum_rev_rev := rev(cumsum(rev(rret_users)))] rret_stat[, rolling_ret := rret_users_cum_rev_rev / rret_users_cum_rev_rev[lifetime == 0]] # считаем простой retention без разбивки по платформам или источникам привлечения retention_stat &lt;- retention[, list(returned = uniqueN(user_pseudo_id)), keyby = list(lifetime)] retention_stat[, total_users := returned[lifetime == 0]] retention_stat[, ret := returned / total_users] # собираем обе таблицы ретеншена и рисуем plot_ly(rret_stat, x = ~lifetime, y = ~rolling_ret, type = &#39;scatter&#39;, mode = &#39;lines&#39;, name = &#39;rolling ret&#39;) %&gt;% add_trace(data = retention_stat, y = ~ret, name = &#39;retention rate&#39;) %&gt;% layout( title = &#39;Rolling retention VS Retention rate&#39;, yaxis = list(rangemode = &#39;tozero&#39;) ) Платежные метрики Gross / Net Gross - общая сумма всех платежей Revenue (или Net) - сумма платежей после вычета налогов и комиссии магазина приложений. задача 1 Нарисовать график суммы платежей по дням, с разбивкой по группам лайфтайма пользователей. # импортируем даатсает payments &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/payments_custom.csv&#39;) # считаем количество дней от инсталла payments[, lifetime := pay_dt - install_dt] # делим на группы payments[, lifetime_group := cut(lifetime, breaks = c(-Inf, -1, 0, 7, 28, Inf), ordered_result = TRUE)] # считаем гросс payments_stat &lt;- payments[, list(gross = sum(gross)), keyby = list(pay_dt, lifetime_group)] payments_stat[, total_gross := sum(gross), by = pay_dt] payments_stat[, share := gross / total_gross] # area-plot plot_ly(payments_stat, x = ~pay_dt, y = ~gross, color = ~lifetime_group, type = &#39;scatter&#39;, mode = &#39;none&#39;, stackgroup = &#39;one&#39;) %&gt;% layout( title = &#39;Gross по группам пользователей&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(title = &#39;&#39;, rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) Конверсия Conversion = N Paying Users / N Users Конверсия обычно считается в каком-то “окне”, - минимальном общем количестве дней, которые могли прожить в приложении пользователи разных сегментов когорт. Например, пользователи, которые пришли месяц назад, могли платить 30 дней. Пользователи, которые пришли пять дней назад - могли платить только пять дней. Соответственно, если мы хотим сравнивать конверсию этих двух когорт, то считать надо с ограничением в пять дней - сколько пользователей первой когорты сконвертировалось за пять дней в приложении (несмотря на то, что они пришли месяц назад), и сколько пользователей второй когорты сконвертировалось за пять дней. Аналогично, когда оцениваем конверсию месячной когорты (всех пользователей, которые, например, пришли в сентябре), то надо так же считать конверсию только за какое-то определенное количество дней, чтобы не было перекосов из-за неравномерной длительности жизни пользователей в приложении. задача 2 Посчитать, какая доля пользователей, которая пришла в июне, стала платящими в интервале 30 дней от инсталла. Алгоритм 1 (не очень гибкий): - посчитать количество платящих в payments, у которых install_dt был в июне, а lifetime (дата платежа - дата инсталла) меньше или равен 30 - по таблице installs посчитать, сколько всего пришло пользователей в июне - поделить одно на другое # импортируем инсталлы installs &lt;- fread(&#39;https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv&#39;) # создаем епременную лайфтайма payments[, lifetime := as.numeric(pay_dt - install_dt)] # выделяем сегмент пользователей payers_june &lt;- payments[install_dt &gt;= &#39;2022-06-01&#39; &amp; install_dt &lt; &#39;2022-07-01&#39;] payers_june &lt;- payers_june[lifetime &gt;= 0 &amp; lifetime &lt;= 30] payers_june[, uniqueN(user_pseudo_id)] / installs[dt &gt;= &#39;2022-06-01&#39; &amp; dt &lt; &#39;2022-07-01&#39;, uniqueN(user_pseudo_id)] ## [1] 0.02343383 Алгоритм 2, тоже не очень гибкий - посчитать минимальный лайфтайм пользователей по таблице платежей - приджойнить результат к таблице инсталлов - посчитать количество пользователей всего и количество пользователей с ненулевым лайфтаймом - поделить одно на другое payers_min &lt;- payments[install_dt &gt;= &#39;2022-06-01&#39; &amp; install_dt &lt; &#39;2022-07-01&#39;] payers_min &lt;- payers_min[lifetime &lt;= 30] payers_min &lt;- payers_min[, list(min_pay_dt = min(pay_dt)), by = user_pseudo_id] jun_payers_min &lt;- merge( installs[dt &gt;= &#39;2022-06-01&#39; &amp; dt &lt; &#39;2022-07-01&#39;], payers_min, by = &#39;user_pseudo_id&#39;, all.x = TRUE ) jun_payers_min_stat &lt;- jun_payers_min[, list( total_users = uniqueN(user_pseudo_id), payers = uniqueN(user_pseudo_id[!is.na(min_pay_dt)]))] jun_payers_min_stat[, payers / total_users] ## [1] 0.02347897 задача 3 Посчитайте накопительную конверсию по когорте июньских пользователей. # ограничиваем датасет по инсталлам payments_june &lt;- payments[install_dt &lt; &#39;2022-07-01&#39;] payments_june &lt;- payments_june[, list(lifetime = min(lifetime)), by = user_pseudo_id] # и по лайфтайму payments_june &lt;- payments_june[lifetime &lt;= 30] payments_june &lt;- payments_june[lifetime &gt;= 0] # читаем количество пользователей, сделавших платеж payments_june_stat &lt;- payments_june[, list(n_payers = uniqueN(user_pseudo_id)), by = lifetime] setkey(payments_june_stat, lifetime) # кумулята и значение накопительной конверсии payments_june_stat[, payers_cum := cumsum(n_payers)] payments_june_stat[, conversion := payers_cum / installs[dt &lt; &#39;2022-07-01&#39;, uniqueN(user_pseudo_id)]] plot_ly(payments_june_stat, x = ~lifetime, y = ~conversion, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% layout( title = &#39;Накопительная конверсия в платящих&#39;, xaxis = list(title = &#39;&#39;), yaxis = list(title = &#39;&#39;, rangemode = &#39;tozero&#39;)) %&gt;% config(displayModeBar = FALSE) Полезные материалы What Is a Business Model? 30 Successful Types of Business Models You Need to Know Коротко, что такое бизнес-модели, рассматриваются 30 разных моделей. Полезно для понимания, как вообще могут зарабатывать разные продукты. Основные метрики мобильных приложений Очень обзорный материал от devtodev. Есть неплохой блок по метрикам монетизации. Домашнее задание Домашние занятия для желающих. Если будут вопросы или необходимость получить от меня какие-то комментарии - пишите в личку в slack. Задание можете выполнять на любом доступном вам языке / среде для статистики. level 1 (IATYTD) Прочитайте конспект, разберите практические занятия. Обновите знания по работе с табличками — агрегации (группировки), слияния, создание и модификация колонок. level 2 (HNTR) Постройте график накопительной конверсии с разбивкой по источнику пользователей. Датасеты: - инсталлы: https://gitlab.com/hse_mar/mar211f/-/raw/main/data/installs.csv - платежи: ‘https://gitlab.com/hse_mar/mar211f/-/raw/main/data/payments_custom.csv’ level 3 (HMP) Посчитайте по каждой платформе конверсию в платящих в день инсталла. Когорта – пришедшие в июне. Делать аналогично динамике ретеншена первого дня. level 4 (UV) Постройте по платформам накопительную кривую конверсии по дням от инсталла (по аналогии с накопительным ARPU). level 5 (N) Посчитайте по каждой платформе конверсию в платящих в день инсталла, суммарно на 3, 7 и 30 дни. Когорта – пришедшие в июне. Должна получиться табличка. ## platform total_users day 0 day 3 day 7 day 30 ## 1: ANDROID 77770 0.005 0.010 0.011 0.015 ## 2: IOS 33010 0.014 0.029 0.035 0.044 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
